import React from 'react';
import styled from 'styled-components';
import colormap from 'colormap';
import { Tooltip } from 'antd';

import { InterpreterId } from './InterpreterId';

export interface GradInputInstance {
    grad_input_1: number[];
    grad_input_2: number[];
}

export interface InterpreterData {
    simple_gradient: { instance_1: GradInputInstance };
    integrated_gradient: { instance_1: GradInputInstance };
    smooth_gradient: { instance_1: GradInputInstance };
}

export interface AllInterpreterData {
    simple?: [number[], number[]];
    ig?: [number[], number[]];
    sg?: [number[], number[]];
}

export const getDescription = (interpreter: InterpreterId) => {
    let description;
    if (interpreter === InterpreterId.SimpleGradient) {
        description = (
            <p>
                See saliency map interpretations generated by{' '}
                <a href="https://arxiv.org/abs/1312.6034" target="_blank" rel="noopener noreferrer">
                    visualizing the gradient
                </a>
                .{' '}
            </p>
        );
    } else if (interpreter === InterpreterId.IntegratedGradient) {
        description = (
            <p>
                See saliency map interpretations generated using{' '}
                <a
                    href="https://arxiv.org/abs/1703.01365"
                    target="_blank"
                    rel="noopener noreferrer">
                    Integrated Gradients
                </a>
                .
            </p>
        );
    } else if (interpreter === InterpreterId.SmoothGradient) {
        description = (
            <p>
                See saliency map interpretations generated using{' '}
                <a
                    href="https://arxiv.org/abs/1706.03825"
                    target="_blank"
                    rel="noopener noreferrer">
                    SmoothGrad
                </a>
                .
            </p>
        );
    }
    return description;
};

const getTokenWeightPairs = (grads: number[], tokens: string[]) => {
    return tokens.map((token, idx: number) => {
        const weight = grads[idx];
        // We do 1 - weight because the colormap is inverted
        return { token, weight: 1 - weight };
    });
};

interface DefaultProps {
    colormapProps: ColorMapProps;
}

interface Props extends DefaultProps {
    interpretData: [number[], number[]];
    inputTokens: [string[], string[]];
    inputHeaders: JSX.Element[];
    interpreter: InterpreterId;
}

interface State {
    topK: { [id: string]: number };
}

interface ColorMapProps {
    colormap: ColorScheme;
    format: ColorMapFormat;
    nshades: number;
}

type ColorMapFormat = 'hex' | 'rgbaString' | 'rba' | 'float';

type ColorScheme =
    | 'jet'
    | 'hsv'
    | 'hot'
    | 'cool'
    | 'spring'
    | 'summer'
    | 'autumn'
    | 'winter'
    | 'bone'
    | 'copper'
    | 'greys'
    | 'YIGnBu'
    | 'greens'
    | 'YIOrRd'
    | 'bluered'
    | 'RdBu'
    | 'picnic'
    | 'rainbow'
    | 'portland'
    | 'blackbody'
    | 'earth'
    | 'electric'
    | 'viridis'
    | 'inferno'
    | 'magma'
    | 'plasma'
    | 'warm'
    | 'rainbow-soft'
    | 'bathymetry'
    | 'cdom'
    | 'chlorophyll'
    | 'density'
    | 'freesurface-blue'
    | 'freesurface-red'
    | 'oxygen'
    | 'par'
    | 'phase'
    | 'salinity'
    | 'temperature'
    | 'turbidity'
    | 'velocity-blue'
    | 'velocity-green'
    | 'cubehelix';

interface TokensWithWeight {
    token: string;
    weight: number;
}

export class Saliency extends React.Component<Props, State> {
    constructor(props: Props) {
        super(props);

        this.state = {
            topK: { all: 3 }, // 3 words are highlighted by default
        };
    }

    static defaultProps: DefaultProps = {
        colormapProps: {
            colormap: 'copper',
            format: 'hex',
            nshades: 20,
        },
    };

    colorize(tokensWithWeights: TokensWithWeight[], topKIdx: Set<number>) {
        const { colormapProps } = this.props;
        // colormap package takes minimum of 6 shades
        colormapProps.nshades = Math.min(Math.max(colormapProps.nshades, 6), 72);
        const colors = colormap(colormapProps);

        const colorizedString = tokensWithWeights.map((obj, idx) => {
            // Again, 1 -, in this case because low extreme is blue and high extreme is red
            return (
                <Tooltip title={(1 - obj.weight).toFixed(3)}>
                    <span key={idx}>
                        <ColorizedToken
                            backgroundColor={
                                topKIdx.has(idx)
                                    ? colors[Math.round(obj.weight * (colormapProps.nshades - 1))]
                                    : 'transparent'
                            }
                            key={idx}>
                            {obj.token}
                        </ColorizedToken>
                    </span>
                </Tooltip>
            );
        });
        return colorizedString;
    }

    // when the user changes the slider for input 1, update how many tokens are highlighted
    handleInputTopKChange = (inputIndex: number) => (e: any) => {
        const stateUpdate = Object.assign({}, this.state);
        if (e.target.value.trim() === '') {
            stateUpdate.topK[inputIndex] = e.target.value;
        } else {
            stateUpdate.topK[inputIndex] = parseInt(e.target.value, 10);
        }
        this.setState(stateUpdate);
    };

    // Extract top K tokens by saliency value and return only the indices of the top tokens
    getTopKIndices(tokensWithWeights: TokensWithWeight[], inputIndex: number) {
        function gradCompare(obj1: TokensWithWeight, obj2: TokensWithWeight) {
            return obj1.weight - obj2.weight;
        }

        // Add indices so we can keep track after sorting
        const indexedTokens = tokensWithWeights.map((obj, idx) => {
            return { ...obj, ...{ idx } };
        });
        indexedTokens.sort(gradCompare);

        const k = inputIndex in this.state.topK ? this.state.topK[inputIndex] : this.state.topK.all;
        const topKTokens = indexedTokens.slice(0, k);
        return topKTokens.map((obj) => obj.idx);
    }

    render() {
        const { interpretData, inputTokens, inputHeaders, interpreter } = this.props;
        const description = getDescription(interpreter);

        const saliencyMaps = [];
        for (let i = 0; i < inputTokens.length; i++) {
            const grads = interpretData[i];
            const tokens = inputTokens[i];
            const header = inputHeaders[i];
            const tokenWeights = getTokenWeightPairs(grads, tokens);
            // indices with the top gradient values
            const topKIdx = new Set(this.getTopKIndices(tokenWeights, i));
            // the tokens highlighted based on their top values
            const colorMap = this.colorize(tokenWeights, topKIdx);
            const k = i in this.state.topK ? this.state.topK[i] : this.state.topK.all;
            const saliencyMap = (
                <div key={i}>
                    {header}
                    {colorMap}
                    <Slider
                        type="range"
                        min={0}
                        max={colorMap.length}
                        step="1"
                        value={k}
                        onChange={this.handleInputTopKChange(i)}
                    />
                    <br />
                    <Info>Visualizing the top {k} most important words.</Info>
                    <br />
                    <br />
                </div>
            );
            saliencyMaps.push(saliencyMap);
        }
        const displayText = <div>{saliencyMaps}</div>;

        return (
            <>
                <div>{description}</div>
                {displayText}
            </>
        );
    }
}

const ColorizedToken = styled.span<{ backgroundColor: string }>`
    background-color: ${({ backgroundColor }) => backgroundColor};
    padding: 1px;
    margin: 1px;
    display: inline-block;
    border-radius: ${({ theme }) => theme.shape.borderRadius.default};
`;

const Info = styled.span`
    color: ${({ theme }) => theme.color.B3};
`;

// TODO: just use antd slider
const Slider = styled.input`
    padding: 0;
    margin: ${({ theme }) => theme.spacing.sm} 0;
    width: 100%;
    height: ${({ theme }) => theme.spacing.sm};
    background-image: linear-gradient(to right, rgb(211, 235, 255), rgb(78, 172, 255));
    outline: none;
    opacity: 0.7;
    transition: opacity 0.2s;
    border-radius: ${({ theme }) => theme.shape.borderRadius.lg};
    padding: 0 ${({ theme }) => theme.spacing.md};

    &:hover {
        opacity: 1;
    }

    &::-webkit-slider-thumb {
        appearance: none;
        width: ${({ theme }) => theme.spacing.lg};
        height: ${({ theme }) => theme.spacing.lg};
        margin-right: ${({ theme }) => theme.spacing.lg};
        background: ${({ theme }) => theme.color.B4};
        cursor: pointer;
    }

    &::-moz-range-thumb,
    &::-webkit-slider-thumb {
        width: ${({ theme }) => theme.spacing.lg};
        height: ${({ theme }) => theme.spacing.lg};
        background: ${({ theme }) => theme.color.B4};
        cursor: pointer;
    }

    &::-webkit-slider-thumb {
        appearance: none;
    }
`;
