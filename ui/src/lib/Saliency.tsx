/**
 * TODO: some of this could be broken out to a more general component.
 */

import React from 'react';
import styled, { createGlobalStyle } from 'styled-components';
import colormap from 'colormap';
import { Popover, Collapse, Tooltip, Button } from 'antd';
import { LinkCSS } from '@allenai/varnish/components';

import { Answer } from '../tugboat/components';

export enum Interpreter {
    GRAD_INTERPRETER = 'simple_gradient',
    IG_INTERPRETER = 'integrated_gradient',
    SG_INTERPRETER = 'smooth_gradient',
}

export interface GradInputInstance {
    grad_input_1: number[];
    grad_input_2: number[];
}

export interface InterpreterData {
    simple_gradient: { instance_1: GradInputInstance };
    integrated_gradient: { instance_1: GradInputInstance };
    smooth_gradient: { instance_1: GradInputInstance };
}

export interface AllInterpreterData {
    simple?: [number[], number[]];
    ig?: [number[], number[]];
    sg?: [number[], number[]];
}

export const getDescription = (interpreter: Interpreter) => {
    let description;
    if (interpreter === Interpreter.GRAD_INTERPRETER) {
        description = (
            <p>
                {' '}
                See saliency map interpretations generated by{' '}
                <a href="https://arxiv.org/abs/1312.6034" target="_blank" rel="noopener noreferrer">
                    visualizing the gradient
                </a>
                .{' '}
            </p>
        );
    } else if (interpreter === Interpreter.IG_INTERPRETER) {
        description = (
            <p>
                {' '}
                See saliency map interpretations generated using{' '}
                <a
                    href="https://arxiv.org/abs/1703.01365"
                    target="_blank"
                    rel="noopener noreferrer">
                    Integrated Gradients
                </a>
                .
            </p>
        );
    } else if (interpreter === Interpreter.SG_INTERPRETER) {
        description = (
            <p>
                {' '}
                See saliency map interpretations generated using{' '}
                <a
                    href="https://arxiv.org/abs/1706.03825"
                    target="_blank"
                    rel="noopener noreferrer">
                    SmoothGrad
                </a>
                .
            </p>
        );
    }
    return description;
};

const getTokenWeightPairs = (grads: number[], tokens: string[]) => {
    return tokens.map((token, idx: number) => {
        const weight = grads[idx];
        // We do 1 - weight because the colormap is inverted
        return { token, weight: 1 - weight };
    });
};

const PopoverWidthFix = createGlobalStyle`
  .ant-popover{
    max-width: 70%;
  }
`;

interface SaliencyMapsProps<I> {
    interpretData: AllInterpreterData;
    inputTokens: [string[], string[]];
    inputHeaders: JSX.Element[];
    interpretModel: Function; // TODO: what type is this
    requestData: I; // Input
}

export const SaliencyMaps = <I,>({
    interpretData,
    inputTokens,
    inputHeaders,
    interpretModel,
    requestData,
}: SaliencyMapsProps<I>) => {
    const simpleGradData = interpretData.simple;
    const integratedGradData = interpretData.ig;
    const smoothGradData = interpretData.sg;
    const popContent = (
        <div>
            <p>
                Despite constant advances and seemingly super-human performance on constrained
                domains, state-of-the-art models for NLP are imperfect. These imperfections, coupled
                with today's advances being driven by (seemingly black-box) neural models, leave
                researchers and practitioners scratching their heads asking,{' '}
                <i>why did my model make this prediction?</i>
            </p>
            <a href="https://allennlp.org/interpret" target="_blank" rel="noopener noreferrer">
                Learn More
            </a>
        </div>
    );
    const interpretationHeader = (
        <>
            Model Interpretations
            <PopoverWidthFix />
            <Popover content={popContent} title="Model Interpretations">
                <WhatIsThis>What is this?</WhatIsThis>
            </Popover>
        </>
    );
    return (
        <Answer.Section label={interpretationHeader}>
            <Collapse>
                {simpleGradData ? (
                    <Collapse.Panel key="Simple" header="Simple Gradients Visualization">
                        <SaliencyComponent
                            interpretData={simpleGradData}
                            inputTokens={inputTokens}
                            inputHeaders={inputHeaders}
                            interpretModel={interpretModel(
                                requestData,
                                Interpreter.GRAD_INTERPRETER
                            )}
                            interpreter={Interpreter.GRAD_INTERPRETER}
                        />
                    </Collapse.Panel>
                ) : null}
                {integratedGradData ? (
                    <Collapse.Panel key="Integrated" header="Integrated Gradients Visualization">
                        <SaliencyComponent
                            interpretData={integratedGradData}
                            inputTokens={inputTokens}
                            inputHeaders={inputHeaders}
                            interpretModel={interpretModel(requestData, Interpreter.IG_INTERPRETER)}
                            interpreter={Interpreter.IG_INTERPRETER}
                        />
                    </Collapse.Panel>
                ) : null}
                {smoothGradData ? (
                    <Collapse.Panel key="SmoothGrad" header="SmoothGrad Visualization">
                        <SaliencyComponent
                            interpretData={smoothGradData}
                            inputTokens={inputTokens}
                            inputHeaders={inputHeaders}
                            interpretModel={interpretModel(requestData, Interpreter.SG_INTERPRETER)}
                            interpreter={Interpreter.SG_INTERPRETER}
                        />
                    </Collapse.Panel>
                ) : null}
            </Collapse>
        </Answer.Section>
    );
};

interface SaliencyComponentProps extends DefaultSaliencyComponentProps {
    interpretData: [number[], number[]];
    inputTokens: [string[], string[]];
    inputHeaders: JSX.Element[];
    interpretModel: Function; // TODO: what is this type;
    interpreter: Interpreter;
}

interface SaliencyComponentState {
    topK: { [id: string]: number };
    loading: boolean;
}

interface DefaultSaliencyComponentProps {
    colormapProps: ColorMapProps;
}

interface ColorMapProps {
    colormap: ColorScheme;
    format: ColorMapFormat;
    nshades: number;
}

type ColorMapFormat = 'hex' | 'rgbaString' | 'rba' | 'float';

type ColorScheme =
    | 'jet'
    | 'hsv'
    | 'hot'
    | 'cool'
    | 'spring'
    | 'summer'
    | 'autumn'
    | 'winter'
    | 'bone'
    | 'copper'
    | 'greys'
    | 'YIGnBu'
    | 'greens'
    | 'YIOrRd'
    | 'bluered'
    | 'RdBu'
    | 'picnic'
    | 'rainbow'
    | 'portland'
    | 'blackbody'
    | 'earth'
    | 'electric'
    | 'viridis'
    | 'inferno'
    | 'magma'
    | 'plasma'
    | 'warm'
    | 'rainbow-soft'
    | 'bathymetry'
    | 'cdom'
    | 'chlorophyll'
    | 'density'
    | 'freesurface-blue'
    | 'freesurface-red'
    | 'oxygen'
    | 'par'
    | 'phase'
    | 'salinity'
    | 'temperature'
    | 'turbidity'
    | 'velocity-blue'
    | 'velocity-green'
    | 'cubehelix';

interface TokensWithWeight {
    token: string;
    weight: number;
}

export class SaliencyComponent extends React.Component<
    SaliencyComponentProps,
    SaliencyComponentState
> {
    constructor(props: SaliencyComponentProps) {
        super(props);

        this.state = {
            topK: { all: 3 }, // 3 words are highlighted by default
            loading: false,
        };
    }

    static defaultProps: DefaultSaliencyComponentProps = {
        colormapProps: {
            colormap: 'copper',
            format: 'hex',
            nshades: 20,
        },
    };

    callInterpretModel = (interpretModel: any) => () => {
        this.setState({ ...this.state, loading: true });
        interpretModel().then(() => this.setState({ loading: false }));
    };

    colorize(tokensWithWeights: TokensWithWeight[], topKIdx: Set<number>) {
        const { colormapProps } = this.props;
        // colormap package takes minimum of 6 shades
        colormapProps.nshades = Math.min(Math.max(colormapProps.nshades, 6), 72);
        const colors = colormap(colormapProps);

        const colorizedString = tokensWithWeights.map((obj, idx) => {
            // Again, 1 -, in this case because low extreme is blue and high extreme is red
            <Tooltip title={(1 - obj.weight).toFixed(3)}>
                <span key={idx}>
                    <ColorizedToken
                        backgroundColor={
                            topKIdx.has(idx)
                                ? colors[Math.round(obj.weight * (colormapProps.nshades - 1))]
                                : 'transparent'
                        }
                        key={idx}>
                        {obj.token}
                    </ColorizedToken>
                </span>
            </Tooltip>;
        });
        return colorizedString;
    }

    // when the user changes the slider for input 1, update how many tokens are highlighted
    handleInputTopKChange = (inputIndex: number) => (e: any) => {
        const stateUpdate = Object.assign({}, this.state);
        if (e.target.value.trim() === '') {
            stateUpdate.topK[inputIndex] = e.target.value;
        } else {
            stateUpdate.topK[inputIndex] = parseInt(e.target.value, 10);
        }
        this.setState(stateUpdate);
    };

    // Extract top K tokens by saliency value and return only the indices of the top tokens
    getTopKIndices(tokensWithWeights: TokensWithWeight[], inputIndex: number) {
        function gradCompare(obj1: TokensWithWeight, obj2: TokensWithWeight) {
            return obj1.weight - obj2.weight;
        }

        // Add indices so we can keep track after sorting
        const indexedTokens = tokensWithWeights.map((obj, idx) => {
            return { ...obj, ...{ idx } };
        });
        indexedTokens.sort(gradCompare);

        const k = inputIndex in this.state.topK ? this.state.topK[inputIndex] : this.state.topK.all;
        const topKTokens = indexedTokens.slice(0, k);
        return topKTokens.map((obj) => obj.idx);
    }

    render() {
        const {
            interpretData,
            inputTokens,
            inputHeaders,
            interpretModel,
            interpreter,
        } = this.props;
        const description = getDescription(interpreter);

        const runButton = (
            <RunButton onClick={this.callInterpretModel(interpretModel)}>
                Interpret Prediction
            </RunButton>
        );

        let displayText;
        if (interpretData === undefined) {
            if (this.state.loading) {
                displayText = (
                    <div>
                        <Note>Loading interpretation...</Note>
                    </div>
                );
            } else {
                displayText = (
                    <div>
                        <Note>Press "interpret prediction" to show the interpretation.</Note>
                        {runButton}
                    </div>
                );
            }
        } else {
            const saliencyMaps = [];
            for (let i = 0; i < inputTokens.length; i++) {
                const grads = interpretData[i];
                const tokens = inputTokens[i];
                const header = inputHeaders[i];
                const tokenWeights = getTokenWeightPairs(grads, tokens);
                // indices with the top gradient values
                const topKIdx = new Set(this.getTopKIndices(tokenWeights, i));
                // the tokens highlighted based on their top values
                const colorMap = this.colorize(tokenWeights, topKIdx);
                const k = i in this.state.topK ? this.state.topK[i] : this.state.topK.all;
                const saliencyMap = (
                    <div key={i}>
                        {header}
                        {colorMap}
                        <Slider
                            type="range"
                            min={0}
                            max={colorMap.length}
                            step="1"
                            value={k}
                            onChange={this.handleInputTopKChange(i)}
                        />
                        <br />
                        <Info>Visualizing the top {k} most important words.</Info>
                        <br />
                        <br />
                    </div>
                );
                saliencyMaps.push(saliencyMap);
            }
            displayText = <div>{saliencyMaps}</div>;
        }

        return (
            <>
                <div>{description}</div>
                {displayText}
            </>
        );
    }
}

export const WhatIsThis = styled.span`
    ${LinkCSS.default()}
    padding-left: ${({ theme }) => theme.spacing.md};
    font-style: italic;
`;

const ColorizedToken = styled.span<{ backgroundColor: string }>`
    background-color: ${({ backgroundColor }) => backgroundColor};
    padding: 1px;
    margin: 1px;
    display: inline-block;
    border-radius: ${({ theme }) => theme.shape.borderRadius.default};
`;

const RunButton = styled(Button)`
    margin: ${({ theme }) => theme.spacing.md} 0;
`;

const Note = styled.p`
    color: ${({ theme }) => theme.palette.text.secondary};
`;

const Info = styled.span`
    color: ${({ theme }) => theme.color.B3};
`;

// TODO: just use antd slider
const Slider = styled.input`
    padding: 0;
    margin: ${({ theme }) => theme.spacing.sm} 0;
    width: 100%;
    height: ${({ theme }) => theme.spacing.sm};
    background-image: linear-gradient(to right, rgb(211, 235, 255), rgb(78, 172, 255));
    outline: none;
    opacity: 0.7;
    transition: opacity 0.2s;
    border-radius: ${({ theme }) => theme.shape.borderRadius.lg};
    padding: 0 ${({ theme }) => theme.spacing.md};

    &:hover {
        opacity: 1;
    }

    &::-webkit-slider-thumb {
        appearance: none;
        width: ${({ theme }) => theme.spacing.lg};
        height: ${({ theme }) => theme.spacing.lg};
        margin-right: ${({ theme }) => theme.spacing.lg};
        background: ${({ theme }) => theme.color.B4};
        cursor: pointer;
    }

    &::-moz-range-thumb,
    &::-webkit-slider-thumb {
        width: ${({ theme }) => theme.spacing.lg};
        height: ${({ theme }) => theme.spacing.lg};
        background: ${({ theme }) => theme.color.B4};
        cursor: pointer;
    }

    &::-webkit-slider-thumb {
        appearance: none;
    }
`;

export default SaliencyMaps;
