import React from 'react';
import styled from 'styled-components';
import { Collapse, Popover } from 'antd';

import { LinkCSS } from '@allenai/varnish/components';

import { Output, Saliency } from '../tugboat/components';
import { Model } from '../tugboat/lib';

import { Interpret } from '.';
import { ModelInfoList } from '../context';
import { InterpreterId } from '../lib';

export interface SaliencyData<O> {
    interpretData: (output: O) => number[];
    tokens: string[];
    header: string;
}

interface Props<I, O> {
    model: Model;
    input: I;
    saliencyData: SaliencyData<O>[];
}

export const Interpreters = <I, O>({ model, input, saliencyData }: Props<I, O>) => {
    const modelInfoList = React.useContext(ModelInfoList);

    const info = modelInfoList.find((i) => i.id === model.id);
    if (!info || info.interpreters.length === 0) {
        return null;
    }

    const supportedInterpreters = new Set(info.interpreters);

    const title = 'Model Interpretations';
    const helpContent = (
        <HelpContent>
            <p>
                Despite constant advances and seemingly super-human performance on constrained
                domains, state-of-the-art models for NLP are imperfect. These imperfections, coupled
                with today's advances being driven by (seemingly black-box) neural models, leave
                researchers and practitioners scratching their heads asking,{' '}
                <i>why did my model make this prediction?</i>
            </p>
            <a href="https://allennlp.org/interpret" target="_blank" rel="noopener noreferrer">
                Learn More
            </a>
        </HelpContent>
    );

    return (
        <Output.Section
            title={title}
            extra={
                <Popover content={helpContent} title={<strong>{title}</strong>}>
                    <PopoverTarget>What is this?</PopoverTarget>
                </Popover>
            }>
            <Collapse>
                {supportedInterpreters.has(InterpreterId.SimpleGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.SimpleGradient}
                        header="Simple Gradient Visualization">
                        <Interpret<I, O>
                            interpreter={InterpreterId.SimpleGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated by{' '}
                                    <a
                                        href="https://arxiv.org/abs/1312.6034"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        visualizing the gradient
                                    </a>
                                    .{' '}
                                </p>
                            }>
                            {({ output }) => (
                                <Interpreter output={output} saliencyData={saliencyData} />
                            )}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
                {supportedInterpreters.has(InterpreterId.IntegratedGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.IntegratedGradient}
                        header="Integrated Gradient Visualization">
                        <Interpret<I, O>
                            interpreter={InterpreterId.IntegratedGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated using{' '}
                                    <a
                                        href="https://arxiv.org/abs/1703.01365"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        Integrated Gradients
                                    </a>
                                    .
                                </p>
                            }>
                            {({ output }) => (
                                <Interpreter output={output} saliencyData={saliencyData} />
                            )}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
                {supportedInterpreters.has(InterpreterId.SmoothGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.SmoothGradient}
                        header="Smooth Gradient Visualization">
                        <Interpret<I, O>
                            interpreter={InterpreterId.SmoothGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated using{' '}
                                    <a
                                        href="https://arxiv.org/abs/1706.03825"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        SmoothGrad
                                    </a>
                                    .
                                </p>
                            }>
                            {({ output }) => (
                                <Interpreter output={output} saliencyData={saliencyData} />
                            )}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
            </Collapse>
        </Output.Section>
    );
};

const Interpreter = <O,>({
    output,
    saliencyData,
}: {
    output: O;
    saliencyData: SaliencyData<O>[];
}) => {
    return (
        <Saliency
            interpretData={saliencyData.map((d) => d.interpretData(output))}
            inputTokens={saliencyData.map((d) => d.tokens)}
            inputHeaders={saliencyData.map((d) => d.header)}
        />
    );
};

const HelpContent = styled.div`
    width: 60ch;

    p {
        margin: 0 0 ${({ theme }) => theme.spacing.sm};
    }
`;

const PopoverTarget = styled.span`
    ${LinkCSS.default()}
    font-style: italic;
`;
