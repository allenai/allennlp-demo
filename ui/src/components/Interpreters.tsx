import React from 'react';
import styled from 'styled-components';
import { Collapse, Popover } from 'antd';

import { LinkCSS } from '@allenai/varnish/components';

import { Output, Saliency } from '../tugboat/components';
import { Model } from '../tugboat/lib';

import { Interpret } from '.';
import { ModelInfoList } from '../context';
import { InterpreterId, WithTokenizedInput } from '../lib';
import { Input } from '../demos/reading-comprehension/types';

export interface InterpreterData {
    instance_1: {
        grad_input_1: number[];
        grad_input_2: number[];
    };
}

interface Props {
    model: Model;
    input: Input;
    tokens: WithTokenizedInput;
}

export const Interpreters = ({ model, input, tokens }: Props) => {
    const modelInfoList = React.useContext(ModelInfoList);

    const info = modelInfoList.find((i) => i.id === model.id);
    if (!info || info.interpreters.length === 0) {
        return null;
    }

    const supportedInterpreters = new Set(info.interpreters);

    const title = 'Model Interpretations';
    const helpContent = (
        <HelpContent>
            <p>
                Despite constant advances and seemingly super-human performance on constrained
                domains, state-of-the-art models for NLP are imperfect. These imperfections, coupled
                with today's advances being driven by (seemingly black-box) neural models, leave
                researchers and practitioners scratching their heads asking,{' '}
                <i>why did my model make this prediction?</i>
            </p>
            <a href="https://allennlp.org/interpret" target="_blank" rel="noopener noreferrer">
                Learn More
            </a>
        </HelpContent>
    );

    return (
        <Output.Section
            title={title}
            extra={
                <Popover content={helpContent} title={<strong>{title}</strong>}>
                    <PopoverTarget>What is this?</PopoverTarget>
                </Popover>
            }>
            <Collapse>
                {supportedInterpreters.has(InterpreterId.SimpleGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.SimpleGradient}
                        header="Simple Gradient Visualization">
                        <Interpret<Input, InterpreterData>
                            interpreter={InterpreterId.SimpleGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated by{' '}
                                    <a
                                        href="https://arxiv.org/abs/1312.6034"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        visualizing the gradient
                                    </a>
                                    .{' '}
                                </p>
                            }>
                            {({ output }) => <Interpreter output={output} tokens={tokens} />}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
                {supportedInterpreters.has(InterpreterId.IntegratedGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.IntegratedGradient}
                        header="Integrated Gradient Visualization">
                        <Interpret<Input, InterpreterData>
                            interpreter={InterpreterId.IntegratedGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated using{' '}
                                    <a
                                        href="https://arxiv.org/abs/1703.01365"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        Integrated Gradients
                                    </a>
                                    .
                                </p>
                            }>
                            {({ output }) => <Interpreter output={output} tokens={tokens} />}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
                {supportedInterpreters.has(InterpreterId.SmoothGradient) ? (
                    <Collapse.Panel
                        key={InterpreterId.SmoothGradient}
                        header="Smooth Gradient Visualization">
                        <Interpret<Input, InterpreterData>
                            interpreter={InterpreterId.SmoothGradient}
                            input={input}
                            description={
                                <p>
                                    See saliency map interpretations generated using{' '}
                                    <a
                                        href="https://arxiv.org/abs/1706.03825"
                                        target="_blank"
                                        rel="noopener,noreferrer">
                                        SmoothGrad
                                    </a>
                                    .
                                </p>
                            }>
                            {({ output }) => <Interpreter output={output} tokens={tokens} />}
                        </Interpret>
                    </Collapse.Panel>
                ) : null}
            </Collapse>
        </Output.Section>
    );
};

const Interpreter = ({
    output,
    tokens,
}: {
    output: InterpreterData;
    tokens: WithTokenizedInput;
}) => {
    return (
        <Saliency
            interpretData={[output.instance_1.grad_input_2, output.instance_1.grad_input_1]}
            inputTokens={[tokens.question_tokens, tokens.passage_tokens]}
            inputHeaders={['Question', 'Passage']}
        />
    );
};

const HelpContent = styled.div`
    width: 60ch;

    p {
        margin: 0 0 ${({ theme }) => theme.spacing.sm};
    }
`;

const PopoverTarget = styled.span`
    ${LinkCSS.default()}
    font-style: italic;
`;
